help(devtools)
install.packages("KernSmooth")
install.packages(KernSmoothR)
install.packages("devtools")
detach("package:datasets", unload = TRUE)
library(KernSmooth)
install.packages("rmarkdown")
library(statsr)
#Data setup
#Set options and functions
options(max.print = 100000)
library(emmeans)
library(statsr)
Help(pkg)
uninstall.packages(ggplot2)
uninstall.packages("ggplot2")
remove.packages(ggplot2)
remove.packages("ggplot2")
if(x>3) {
y<-10
}else{
y<-0
}
x<-7
if(x>3) {
y<-10
}else{
y<-0
}
if(x>3) {
y<-10
}else{
y<-0
}
add2 <- function(x, y) {
x + y
}
add2(3, 5)
above10 <- function(x){
use <- x > 10
x[use]
}
above <- function(x, n) {
use <- x >n
x[use]
}
above(x, 12)
x <- 1:20
above(x, 12)
above <- function(x, n = 10) {
use <- x >n
x[use]
}
x <- 1:20
above <- function(x, n = 10) {
use <- x >n
x[use]
}
x <- 1:20
above(x)
columnname <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[, i])
}
columnname <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[, i])
}
means
}
columnnmean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[, i])
}
means
}
columnnmean
columnnmean(x)
dir()
hw1_data <- read.csv("C:/Users/Matthew.Clark2/Desktop/Data Scientists Specilization/R Programming course/hw1_data.csv", stringsAsFactors=TRUE)
View(hw1_data)
hw1_data <- read.csv("C:/Users/Matthew.Clark2/Desktop/Data Scientists Specilization/R Programming course/hw1_data.csv", stringsAsFactors=TRUE)
View(hw1_data)
dir()
airquality <- read.csv("C:/Users/Matthew.Clark2/Desktop/Data Scientists Specilization/R Programming course/hw1_data.csv", stringsAsFactors=TRUE)
airquality <- read.csv("C:/Users/Matthew.Clark2/Desktop/Data Scientists Specilization/R Programming course/hw1_data.csv", stringsAsFactors=TRUE)
airquality<-read.csv("C:/Users/Matthew.Clark2/Desktop/Data Scientists Specilization/R Programming course/hw1_data.csv", stringsAsFactors=TRUE)
hw1_data <- read.csv("C:/Users/Matthew.Clark2/Desktop/Data Scientists Specilization/R Programming course/hw1_data.csv", stringsAsFactors=TRUE)
View(hw1_data)
View(hw1_data)
View(hw1_data)
install.packages("foreign")
install.packages("Rtools")
install.packages("haven")
library(haven)
dataset <- read_sas(NULL, NULL)
View(dataset)
title'Raw Import';
proc import datafile='N:\Pat.Clark\Ben Porter\Summary Report Analysis\Boise 2019\Boise_2019_Gap_alldata_Clark.csv'
out=temp0
dbms=csv replace;
getnames=yes;
run;
proc print;
run;
* Drop formatting row and create transformed responses;
data temp1; set temp0;
if line = -99 then delete;
if type = 'B';
gap = gap + 0.01; *comment out if not using the log transform;
loggap=log(gap);
if loggap="." then loggap=0;
sqrtgap=sqrt(gap);
invgap=1/gap;
if invgap="." then invgap=0;
proc sort;
by site plot line;
proc print;
run;
* do a histogram to find the outliers;
proc univariate data=temp1;
histogram gap;
run;
* Full model GLM for basal gap (hydrologic variable and a measure of surface fuel continuity as well;
title' Basal Gap with log transformation';
proc mixed data=temp1 plots(maxpoints=10000); * using proc mixed here mainly for the residual display...otherwise gives same answers as proc glm;
class treatment site;
model loggap=treatment|site/residual;
lsmeans treatment site treatment*site/cl adjust=tukey;
run;
columnmean <- function(y){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
mean[i] <- mean(y[, i])
}
means
}
hw1_data <- read.csv("C:/Users/Matthew.Clark2/Desktop/Data Scientists Specilization/R Programming course/hw1_data.csv", stringsAsFactors=TRUE)
View(hw1_data)
columnmean(hw1_data)
View(hw1_data)
columnmean(hw1_data$Ozone)
columnmean($Ozone~hw1_data)
columnmean(Ozone~hw1_data)
columnmean(Ozone, data = hw1_data)
hw1_data <- read.csv("C:/Users/Matthew.Clark2/Desktop/Data Scientists Specilization/R Programming course/hw1_data.csv", stringsAsFactors=TRUE)
View(hw1_data)
columnmean(hw1_data)
columnmean <- function(y){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[, i])
}
means
}
columnmean(hw1_data)
columnmean <- function(y, removeNA =TRUE){
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc){
means[i] <- mean(y[, i], na.rm = removeNA)
}
means
}
columnmean(hw1_data)
columnmean(hw1_data, FALSE)
f(2)
f <- function (a,b) {
a^2
}
f(2)
search()
View(columnmean)
View(columnmean)
View(columnmean)
View(columnmean)
View(f)
View(f)
View(f)
View(hw1_data)
View(columnmean)
View(hw1_data)
View(f)
View(columnmean)
View(f)
force(qbirthday)
View(ftable)
function (x, ...)
View(ftable)
View(hatvalues)
View(monthplot)
UseMethod("monthplot")
View(na.omit)
View(drop1)
View(qqnorm)
View(qqnorm)
View(ppr)
UseMethod("ppr")
function (x, ...)
View(getClass)
View(getClasses)
View(substituteFunctionArgs)
#Data setup
#Set options and functions
options(max.print = 100000)
library(emmeans)
library(statsr)
library(ggpubr)
force(ames)
force(calc_streak)
force(inference)
force(nycflights)
view(TukeyHSD)
showMethods(TukeyHSD)
generics::TukeyHSD
getMethod(TukeyHSD)
install.packages("ezANOVA")
install.packages("Rtools")
nstall.Rtools(TRUE)
install.Rtools(TRUE)
install.Rtools(TRUE)
install.Rtools(choose_version = TRUE, check = FALSE, GUI = TRUE,
page_with_download_url = "https://cran.r-project.org/bin/windows/Rtools/",
...)
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
View(columnmean)
help(workspace)
q()
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) {inv <<- inverse}
getInverse <- function() {inv}
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(!is.null(inv)) {
message("getting inversed matrix")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
qmatrix <- makeCacheMatrix(matrix(1:16, nrow=4, ncol=4))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(1:4, nrow=4, ncol=4))
qmatrix$get()
qmatrix <- makeCacheMatrix(matrix(1:4, nrow=2, ncol=2))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) {inv <<- inverse}
getInverse <- function() {inv}
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(!is.null(inv)) {
message("getting inversed matrix")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
qmatrix <- makeCacheMatrix(matrix(1:4, nrow=2, ncol=2))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(1:8, nrow=2, ncol=4))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(1:8, nrow=4, ncol=4))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix$get()
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) {inv <<- inverse}
getInverse <- function() {inv}
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(!is.null(inv)) {
message("getting inversed matrix")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
qmatrix <- makeCacheMatrix(matrix(1:8, nrow=2, ncol=2))
qmatrix$get()
qmatrix$getInverse()
qmatrix <- makeCacheMatrix(matrix(1:, nrow=4, ncol=4))
qmatrix <- makeCacheMatrix(matrix(1:4, nrow=4, ncol=4))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(1:4, nrow=2, ncol=2))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(1:8, nrow=4, ncol=4))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(1:8, nrow=2, ncol=4))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(1:8, nrow=4, ncol=4))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) {inv <<- inverse}
getInverse <- function() {inv}
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(!is.null(inv)) {
message("getting inversed matrix")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
qmatrix <- makeCacheMatrix(matrix(1:8, nrow=4, ncol=4))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(1:8,2,4))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(1:8,2,2))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(1:4,2,2))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(1:4,2,2))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(c(2, 2, 1, 4), 2, 2))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
## The functions below caches the Inverse of a Matrix
## The makeCacheMatrix and cacheSolve functions are used to create a matrix and cache its inverse.
##The below function creates a special matrix object that can be used to cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) {inv <<- inverse}
getInverse <- function() {inv}
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
## The below cacheSolve function computes the inverse of the special matrix created by the
## makeCacheMatrix function above.
cacheSolve <- function(x, ...) {
inv <- x$getInverse()
if(!is.null(inv)) {
message("getting inversed matrix")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
#Test that the function work properly
qmatrix <- makeCacheMatrix(matrix(1:4,2,2))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
qmatrix <- makeCacheMatrix(matrix(c(2, 2, 1, 4), 2, 2))
qmatrix$get()
qmatrix$getInverse()
cacheSolve(qmatrix)
#Data setup
#Set options and functions
options(max.print = 100000)
library(emmeans)
library(statsr)
library(ggpubr)
library(ggplot2)
library(tidyverse)
library(broom)
library(AICcmodavg)
library(car)
#Set working directory
setwd("C:/Users/Matthew.Clark2/Desktop/TG_2020_SummaryReportAnalysis/Boise 2020")
#Data import
BoiseGap2020<- read.csv("C:/Users/Matthew.Clark2/Desktop/TG_2020_SummaryReportAnalysis/Boise 2020/Boise_2020_Gap_alldata_norton110420.csv", stringsAsFactors=TRUE)
#Error check
table(BoiseGap2020$Gap)
ggdensity(BoiseGap2020$Gap)
ggqqplot(BoiseGap2020$Gap)
#Subset Gap Type
BasalBoise<-subset(BoiseGap2020, Type == "B")
#Transformation
Basallog<-log(BasalBoise$Gap + 0.001)
#Estimate calculations
#Multivariate model
fit=glm(Basallog~(Treatment + Site)^2, data = BasalBoise)
#Univariate estimates
emmeans(fit,~Site)
emmeans(fit,~Treatment)
#Multivariate estimates
emmeans(fit,~Site*Treatment)
#P-value calculations
#Type 3 Test of Fixed Effects
Basaltype3 <- tibble(BasalBoise, Basallog = Basallog)
newlm <- lm(Basallog ~ Treatment*Site, contrasts = list(Treatment = contr.sum, Site = contr.sum),data = Basaltype3)
Anova(newlm, type = "III")
str(Anova(newlm, type = "III"))
str(anovax, Type "III")
str(Anova, Type "III")
set.seed(1)
rnorm(5)
library(swirl)
set.seed(1)
rpois(5, 2)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
setwd("C:/Users/Matthew.Clark2/Desktop/Data Scientists Specilization/R Programming course/Programming Assignment 3")
setwd("C:/Users/Matthew.Clark2/Desktop/Data Scientists Specilization/R Programming course/Programming Assignment 3")
dir()
setwd("C:/Users/Matthew.Clark2/Desktop/Data Scientists Specilization/R Programming course/Programming Assignment 3/Programming Assignment 3 Data")
setwd("C:/Users/Matthew.Clark2/Desktop/Data Scientists Specilization/R Programming course/Programming Assignment 3 Data")
dir()
outcome <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
head(outcome)
View(outcome)
view(outcome)
#number of columns in outcome
ncol(outcome)
#numbe rof rows in outcome
nrow(outcome)
#names of each column
names(outcome)
View(outcome)
outcome[, 11] <- as.numeric(outcome[, 11])
## You may get a warning about NAs being introduced; that is okay
hist(outcome[, 11])
